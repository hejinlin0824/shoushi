<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CYBERPUNK NEURAL LINK v4.0 // MOBILE FIT</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root { --neon-blue: #00f3ff; --neon-pink: #ff0055; --neon-yellow: #fcee0a; --bg-dark: #050505; --glass: rgba(0, 20, 30, 0.85); }
        
        body { 
            margin: 0; overflow: hidden; background-color: var(--bg-dark); 
            font-family: 'Share Tech Mono', monospace; color: var(--neon-blue); 
            user-select: none; -webkit-user-select: none; touch-action: none; /* ç¦æ­¢é»˜è®¤è§¦æ‘¸è¡Œä¸º */
        }
        
        /* è§†è§‰ç‰¹æ•ˆå±‚ */
        #crt-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06)); background-size: 100% 2px, 3px 100%; pointer-events: none; z-index: 999; }
        #vignette { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.8) 100%); pointer-events: none; z-index: 998; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }

        /* HUD - é¡¶éƒ¨çŠ¶æ€ */
        #hud-top { position: absolute; top: 15px; width: 100%; z-index: 10; text-align: center; pointer-events: none; }
        #status-box { 
            display: inline-block;
            border: 1px solid var(--neon-blue); background: var(--glass); padding: 8px 25px; 
            clip-path: polygon(15px 0, 100% 0, 100% 70%, calc(100% - 15px) 100%, 0 100%, 0 30%); 
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.15); backdrop-filter: blur(4px); transition: all 0.3s; 
        }
        #gesture-icon { font-size: 24px; display: block; line-height: 1; text-shadow: 0 0 10px currentColor; }
        #gesture-text { font-size: 12px; letter-spacing: 2px; font-weight: bold; margin-top: 4px; }

        /* HUD - æ‘„åƒå¤´ (ç§»åŠ¨ç«¯æ”¾åœ¨å·¦ä¸Šè§’) */
        #cam-wrapper { 
            position: absolute; top: 15px; left: 15px; z-index: 15; 
            width: 80px; height: 60px; 
            border: 1px solid var(--neon-pink); background: #000; 
            box-shadow: 0 0 10px rgba(255, 0, 85, 0.2);
            pointer-events: auto; /* å…è®¸ç‚¹å‡» */
            transition: opacity 0.3s;
        }
        #cam-wrapper.hidden { opacity: 0; pointer-events: none; }
        #video-input { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.6; filter: grayscale(100%) contrast(1.2); }
        .cam-label { position: absolute; bottom: 0; right: 0; background: var(--neon-pink); color: #000; font-size: 8px; padding: 1px 3px; font-weight: bold; }

        /* ==================== èµ›åšæ§åˆ¶é¢æ¿ ==================== */
        #cyber-panel {
            position: absolute; 
            z-index: 20;
            background: rgba(5, 12, 18, 0.95);
            border: 1px solid rgba(0, 243, 255, 0.3);
            backdrop-filter: blur(10px);
            font-family: 'Share Tech Mono';
            transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1); /* å¹³æ»‘è¿‡æ¸¡åŠ¨ç”» */
            display: flex; flex-direction: column;
        }
        
        /* æ¡Œé¢ç«¯æ ·å¼ (é»˜è®¤) */
        @media (min-width: 769px) {
            #cyber-panel {
                top: 50%; right: 20px; transform: translateY(-50%);
                width: 280px; max-height: 80vh; overflow-y: auto;
                padding: 20px;
                clip-path: polygon(0 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%);
            }
            #panel-header { display: none; } /* æ¡Œé¢ç«¯ä¸éœ€è¦æŠ˜å æ¡ */
        }

        /* ç§»åŠ¨ç«¯æ ·å¼ (åº•éƒ¨æŠ½å±‰) */
        @media (max-width: 768px) {
            #cyber-panel {
                bottom: 0; left: 0; width: 100%; 
                border-radius: 15px 15px 0 0;
                border-bottom: none; border-left: none; border-right: none;
                border-top: 1px solid var(--neon-blue);
                box-shadow: 0 -5px 20px rgba(0,0,0,0.5);
                padding: 0; /* paddingç”±å†…éƒ¨å…ƒç´ æ§åˆ¶ */
                max-height: 60vh; /* æœ€å¤§é«˜åº¦ */
            }
            
            /* æœ€å°åŒ–çŠ¶æ€ï¼šå‘ä¸‹ç§»åŠ¨ï¼Œåªéœ²å‡ºå¤´éƒ¨ */
            #cyber-panel.minimized {
                transform: translateY(calc(100% - 40px)); /* ä¿ç•™40pxå¤´éƒ¨ */
            }

            /* ç§»åŠ¨ç«¯å†…å®¹åŒºåŸŸæ»šåŠ¨ */
            #panel-content {
                padding: 20px;
                overflow-y: auto;
                /* å¢åŠ åº•éƒ¨ç©ºé—´é˜²æ­¢ç”±äºiPhoneåº•éƒ¨æ¡å¯¼è‡´ç‚¹ä¸åˆ° */
                padding-bottom: 40px; 
            }
        }

        /* ç§»åŠ¨ç«¯æŠ˜å æ§åˆ¶æ¡ */
        #panel-header {
            height: 40px;
            background: linear-gradient(90deg, rgba(0, 243, 255, 0.1), rgba(0, 243, 255, 0.05));
            border-bottom: 1px solid rgba(0, 243, 255, 0.2);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            font-size: 12px; letter-spacing: 2px; color: var(--neon-blue);
            font-weight: bold;
            flex-shrink: 0;
        }
        #panel-header:active { background: rgba(0, 243, 255, 0.2); }
        .toggle-arrow { transition: transform 0.3s; display: inline-block; margin-right: 8px; }
        /* æœ€å°åŒ–æ—¶ç®­å¤´æœä¸Š */
        .minimized .toggle-arrow { transform: rotate(180deg); }

        /* æ§ä»¶é€šç”¨æ ·å¼ */
        .panel-section { margin-bottom: 15px; border-left: 2px solid rgba(255,255,255,0.1); padding-left: 10px; }
        .section-title { color: var(--neon-pink); font-size: 12px; font-weight: bold; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }
        .control-row { margin-bottom: 12px; }
        .control-label { display: flex; justify-content: space-between; font-size: 11px; color: #889; margin-bottom: 5px; }
        .control-val { color: var(--neon-yellow); font-family: 'Orbitron'; }
        
        select.cyber-select {
            width: 100%; background: #081015; border: 1px solid var(--neon-blue); color: var(--neon-blue);
            padding: 8px; font-family: 'Share Tech Mono'; outline: none; border-radius: 4px;
        }
        
        /* ä¼˜åŒ–æ»‘å—è§¦æ‘¸åŒºåŸŸ */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; height: 20px; margin: 0; display: block; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: rgba(0, 243, 255, 0.2); border-radius: 2px; align-self: center; }
        input[type=range]::-webkit-slider-thumb { 
            -webkit-appearance: none; height: 18px; width: 18px; margin-top: -7px; 
            background: var(--neon-blue); border-radius: 50%; box-shadow: 0 0 10px var(--neon-blue); 
            border: 2px solid #fff;
        }

        /* Loading */
        #loader { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 2000; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 0.8s; pointer-events: none; }
        .loader-bar { width: 200px; height: 4px; background: #333; margin-top: 20px; position: relative; overflow: hidden; }
        .loader-progress { position: absolute; top: 0; left: 0; height: 100%; width: 0%; background: var(--neon-blue); box-shadow: 0 0 10px var(--neon-blue); transition: width 0.3s; }

    </style>
    
    <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>

    <div id="crt-overlay"></div>
    <div id="vignette"></div>

    <div id="loader">
        <h1 style="font-family: 'Orbitron'; letter-spacing: 5px; color: var(--neon-blue);">NEURAL LINK</h1>
        <div style="font-size:10px; color:var(--neon-pink); letter-spacing:2px;">MOBILE OPTIMIZED</div>
        <div class="loader-bar"><div class="loader-progress" id="progress-fill"></div></div>
        <div id="loader-text" style="margin-top: 10px; color: #666; font-size: 12px;">æ­£åœ¨æ ¡å‡†å…‰å­¦ä¼ æ„Ÿå™¨...</div>
    </div>

    <div id="hud-top">
        <div id="status-box">
            <span id="gesture-icon">âš ï¸</span>
            <div id="gesture-text">ç­‰å¾…ä¿¡å·</div>
        </div>
    </div>
    
    <div id="cam-wrapper">
        <video id="video-input" playsinline muted autoplay></video>
        <div class="cam-label">CAM_01</div>
    </div>

    <div id="cyber-panel" class="minimized"> <div id="panel-header">
            <span class="toggle-arrow">â–¼</span> <span id="header-text">ç³»ç»Ÿè®¾ç½® (SYSTEM)</span>
        </div>
        
        <div id="panel-content">
            <div class="panel-section">
                <div class="section-title">æ ¸å¿ƒæ¨¡å¼</div>
                <div class="control-row">
                    <select id="inp-model" class="cyber-select"></select>
                </div>
                <div class="control-row">
                    <div class="control-label">æ¨¡å‹å¤§å° <span id="val-scale" class="control-val">1.0</span></div>
                    <input type="range" id="inp-scale" min="0.1" max="3.0" step="0.01">
                </div>
            </div>

            <div class="panel-section">
                <div class="section-title">è§†è§‰å¾®è°ƒ</div>
                <div class="control-row">
                    <div class="control-label">è¾‰å…‰å¼ºåº¦ <span id="val-bloom" class="control-val">1.5</span></div>
                    <input type="range" id="inp-bloom" min="0" max="4" step="0.1">
                </div>
                <div class="control-row">
                    <div class="control-label">ç²’å­å°ºå¯¸ <span id="val-size" class="control-val">0.15</span></div>
                    <input type="range" id="inp-size" min="0.01" max="0.5" step="0.01">
                </div>
            </div>

            <div class="panel-section">
                <div class="section-title">ç‰©ç†å‚æ•°</div>
                <div class="control-row">
                    <div class="control-label">å¤ä½é€Ÿåº¦ <span id="val-speed" class="control-val">0.08</span></div>
                    <input type="range" id="inp-speed" min="0.01" max="0.3" step="0.001">
                </div>
                <div class="control-row">
                    <div class="control-label">çˆ†ç‚¸åŠ›åº¦ <span id="val-force" class="control-val">15.0</span></div>
                    <input type="range" id="inp-force" min="1.0" max="30.0" step="0.1">
                </div>
            </div>
            
            <div style="text-align:center; font-size:10px; color:#445; margin-top:10px;">
                NEURAL_LINK_V4.0 // CONNECTED
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- ç§»åŠ¨ç«¯æ£€æµ‹ ---
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
        
        // --- UI & DOM ---
        const ui = {
            model: document.getElementById('inp-model'),
            scale: document.getElementById('inp-scale'),
            bloom: document.getElementById('inp-bloom'),
            size: document.getElementById('inp-size'),
            speed: document.getElementById('inp-speed'),
            force: document.getElementById('inp-force'),
            // Labels
            v_scale: document.getElementById('val-scale'),
            v_bloom: document.getElementById('val-bloom'),
            v_size: document.getElementById('val-size'),
            v_speed: document.getElementById('val-speed'),
            v_force: document.getElementById('val-force'),
        };

        const panel = document.getElementById('cyber-panel');
        const panelHeader = document.getElementById('panel-header');
        const gestureText = document.getElementById('gesture-text');
        const gestureIcon = document.getElementById('gesture-icon');
        const videoElement = document.getElementById('video-input');
        
        // --- é¢æ¿æŠ˜å é€»è¾‘ ---
        if(isMobile) {
            panelHeader.addEventListener('click', () => {
                panel.classList.toggle('minimized');
            });
            // ç‚¹å‡»å†…å®¹åŒºåŸŸä»¥å¤–å¦‚æœä¸å°å¿ƒç‚¹åˆ°Headerä¹Ÿå¯ä»¥å¤„ç†ï¼Œä¸è¿‡ä¸»è¦æ˜¯Headerç‚¹å‡»
        } else {
            panel.classList.remove('minimized'); // æ¡Œé¢ç«¯é»˜è®¤å±•å¼€
        }

        // --- Config ---
        const CONFIG = {
            model: "ğŸ§  ç¥ç»ç½‘ç»œ",
            particleCount: isMobile ? 12000 : 30000, 
            globalScale: isMobile ? 1.5 : 2.0,  
            bloomStrength: 1.5,
            particleSize: isMobile ? 0.25 : 0.15,
            colorBase: '#00f3ff', 
            colorAlt: '#ff0055',
            autoRotate: true,
            returnSpeed: 0.08,     
            friction: 0.92,       
            jitter: 0.5,        
            gravity: 0.05,         
            explosionForce: 15.0, 
        };

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // --- å…³é”®ï¼šè‡ªé€‚åº”æ‘„åƒæœºè·ç¦»ç®—æ³• ---
        function adjustCamera() {
            const aspect = window.innerWidth / window.innerHeight;
            let baseZ = 35; 
            
            if (aspect < 1.0) {
                // ç«–å±æ¨¡å¼ï¼šå› ä¸ºå®½åº¦ä¸å¤Ÿï¼Œéœ€è¦å¤§å¹…æ‹‰è¿œæ‘„åƒæœº
                // ç®€å•çš„åæ¯”ç®—æ³•ï¼šé•¿å®½æ¯”è¶Šå°ï¼Œè·ç¦»è¶Šè¿œ
                baseZ = 35 / aspect; 
                // é™åˆ¶æœ€å¤§è·ç¦»é˜²æ­¢å¤ªè¿œ
                baseZ = Math.min(baseZ, 70); 
            }
            
            camera.position.z = baseZ;
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
        }
        
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2)); 
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        composer.addPass(bloomPass);

        // --- Particles ---
        const tex = (() => {
            const c = document.createElement('canvas'); c.width=16; c.height=16;
            const ctx = c.getContext('2d');
            ctx.fillStyle = '#ffffff'; ctx.fillRect(4,4,8,8);
            return new THREE.Texture(c);
        })();
        tex.needsUpdate = true;

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const colors = new Float32Array(CONFIG.particleCount * 3);
        const currentPositions = new Float32Array(CONFIG.particleCount * 3);
        const targetPositions = new Float32Array(CONFIG.particleCount * 3); 
        const velocities = new Float32Array(CONFIG.particleCount * 3);

        for(let i=0; i<CONFIG.particleCount; i++) {
            positions[i*3] = (Math.random()-0.5)*5; positions[i*3+1] = (Math.random()-0.5)*5; positions[i*3+2] = (Math.random()-0.5)*5;
            currentPositions[i*3] = positions[i*3]; currentPositions[i*3+1] = positions[i*3+1]; currentPositions[i*3+2] = positions[i*3+2];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: CONFIG.particleSize, map: tex, vertexColors: true,
            blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.9
        });
        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        const updateColors = (isFirework = false) => {
            const c1 = new THREE.Color(CONFIG.colorBase);
            const c2 = new THREE.Color(CONFIG.colorAlt);
            const attr = geometry.attributes.color;
            for(let i=0; i<CONFIG.particleCount; i++) {
                if (isFirework) {
                    const r = Math.random();
                    let color = new THREE.Color();
                    if (r > 0.8) color.setHex(0xffffff); 
                    else if (r > 0.6) color.setHex(0xffaa00);
                    else if (r > 0.4) color.setHex(0xff0055);
                    else if (r > 0.2) color.setHex(0x00f3ff);
                    else color.setHSL(Math.random(), 1.0, 0.6);
                    attr.setXYZ(i, color.r, color.g, color.b);
                } else {
                    const isBlue = Math.random() > 0.5;
                    attr.setXYZ(i, isBlue?c1.r:c2.r, isBlue?c1.g:c2.g, isBlue?c1.b:c2.b);
                }
            }
            attr.needsUpdate = true;
        };
        updateColors();

        // --- Shapes ---
        const shapes = {
            "ğŸ§  ç¥ç»ç½‘ç»œ": (i) => {
                 const theta = Math.random() * Math.PI * 2, phi = Math.acos(2 * Math.random() - 1);
                 const r = 10 * Math.cbrt(Math.random()); 
                 let x = r * Math.sin(phi) * Math.cos(theta);
                 let y = r * Math.sin(phi) * Math.sin(theta) * 0.8;
                 let z = r * Math.cos(phi);
                 if(x > 0) x += 1; else x -= 1; 
                 return {x,y,z};
            },
            "ğŸª åœŸæ˜Ÿ (Saturn)": (i) => {
                if (i % 3 === 0) {
                    const theta = Math.random() * Math.PI * 2, phi = Math.acos(2 * Math.random() - 1);
                    const r = 4.5;
                    return {x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.sin(phi) * Math.sin(theta), z: r * Math.cos(phi)};
                } else {
                    const theta = Math.random() * Math.PI * 2;
                    const r = 7 + Math.random() * 5; 
                    return {x: r * Math.cos(theta), y: (Math.random()-0.5)*0.2, z: r * Math.sin(theta)};
                }
            },
            "ğŸŒŒ é“¶æ²³ (Galaxy)": (i) => {
                 const arms = 3; const armIndex = i % arms;
                 const r = Math.random() * 12; const spin = r * 0.5; 
                 const theta = (armIndex / arms) * Math.PI * 2 + spin;
                 const randomOffset = (Math.random()-0.5);
                 return { x: r * Math.cos(theta) + randomOffset, y: (Math.random()-0.5) * (2 - r/8), z: r * Math.sin(theta) + randomOffset };
            },
            "ğŸ† çƒŸèŠ±æ¨¡å¼": (i) => null
        };

        // --- UI Logic ---
        Object.keys(shapes).forEach(key => {
            const opt = document.createElement('option');
            opt.value = key; opt.innerText = key;
            ui.model.appendChild(opt);
        });

        function syncUI() {
            ui.scale.value = CONFIG.globalScale; ui.v_scale.innerText = CONFIG.globalScale.toFixed(2);
            ui.bloom.value = CONFIG.bloomStrength; ui.v_bloom.innerText = CONFIG.bloomStrength.toFixed(1);
            ui.size.value = CONFIG.particleSize; ui.v_size.innerText = CONFIG.particleSize.toFixed(2);
            ui.speed.value = CONFIG.returnSpeed; ui.v_speed.innerText = CONFIG.returnSpeed.toFixed(3);
            ui.force.value = CONFIG.explosionForce; ui.v_force.innerText = CONFIG.explosionForce.toFixed(1);
            ui.model.value = CONFIG.model;
        }

        ui.model.addEventListener('change', (e) => switchMode(e.target.value));
        ui.scale.addEventListener('input', (e) => { 
            CONFIG.globalScale = parseFloat(e.target.value); 
            particleSystem.scale.set(CONFIG.globalScale, CONFIG.globalScale, CONFIG.globalScale); 
            ui.v_scale.innerText = CONFIG.globalScale.toFixed(2);
        });
        ui.bloom.addEventListener('input', (e) => {
            CONFIG.bloomStrength = parseFloat(e.target.value);
            bloomPass.strength = CONFIG.bloomStrength;
            ui.v_bloom.innerText = CONFIG.bloomStrength.toFixed(1);
        });
        ui.size.addEventListener('input', (e) => {
            CONFIG.particleSize = parseFloat(e.target.value);
            material.size = CONFIG.particleSize;
            ui.v_size.innerText = CONFIG.particleSize.toFixed(2);
        });
        ui.speed.addEventListener('input', (e) => { CONFIG.returnSpeed = parseFloat(e.target.value); ui.v_speed.innerText = CONFIG.returnSpeed.toFixed(3); });
        ui.force.addEventListener('input', (e) => { CONFIG.explosionForce = parseFloat(e.target.value); ui.v_force.innerText = CONFIG.explosionForce.toFixed(1); });

        function switchMode(name) {
            CONFIG.model = name;
            const isFirework = (name === "ğŸ† çƒŸèŠ±æ¨¡å¼");
            updateColors(isFirework);

            if (isFirework) {
                CONFIG.globalScale = 0.1;
                CONFIG.bloomStrength = 2.8;
                CONFIG.particleSize = isMobile ? 0.35 : 0.25;
                CONFIG.returnSpeed = 0.05;
                updateUI("å‘å°„ç³»ç»Ÿå°±ç»ª", "ğŸš€", "#fcee0a");
            } else {
                CONFIG.globalScale = isMobile ? 1.5 : 2.0;
                CONFIG.bloomStrength = 0.93;
                CONFIG.particleSize = isMobile ? 0.25 : 0.15;
                CONFIG.returnSpeed = 0.08;
                
                const gen = shapes[name];
                for(let i=0; i<CONFIG.particleCount; i++) {
                    const p = gen(i);
                    targetPositions[i*3] = p.x; targetPositions[i*3+1] = p.y; targetPositions[i*3+2] = p.z;
                }
                updateUI("æ¨¡å‹åŠ è½½å®Œæˆ", "ğŸ’ ", "#00f3ff");
            }
            
            particleSystem.scale.set(CONFIG.globalScale, CONFIG.globalScale, CONFIG.globalScale);
            bloomPass.strength = CONFIG.bloomStrength;
            material.size = CONFIG.particleSize;
            syncUI(); 
        }

        function updateUI(text, icon, color) {
            if (!gestureText || !gestureIcon) return;
            if (gestureText.innerText !== text) {
                gestureText.innerText = text;
                gestureText.style.color = color;
                gestureText.parentElement.style.borderColor = color;
                gestureText.parentElement.style.boxShadow = `0 0 15px ${color}40`;
                gestureIcon.innerText = icon;
            }
        }

        // --- Logic ---
        let hands;
        let aiReady = false;
        const mouse = { x: 0, y: 0 };
        const state = { isFist: false, wasFist: false, handCenter: {x:0, y:0} };

        // è§¦æ‘¸/é¼ æ ‡ äº¤äº’
        window.addEventListener('touchmove', (e) => {
            if (e.touches.length > 0 && !aiReady) {
                const t = e.touches[0];
                mouse.x = (t.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(t.clientY / window.innerHeight) * 2 + 1;
            }
        }, { passive: false }); // passive: false å…è®¸é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œä½†ä¸Šé¢æˆ‘ä»¬ç”¨äº† touch-action: none æ‰€ä»¥è¿™é‡Œå¯ä»¥ relaxed

        window.addEventListener('mousemove', (e) => {
            if(!aiReady) {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            }
        });

        function forceHideLoader() {
            const l = document.getElementById('loader');
            if(l) { l.style.opacity = 0; setTimeout(() => l.style.display='none', 800); }
        }

        async function initAI() {
            document.getElementById('progress-fill').style.width = "60%";
            try {
                hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({
                    maxNumHands: 1, 
                    modelComplexity: isMobile ? 0 : 1, 
                    minDetectionConfidence: 0.6
                });
                hands.onResults(onResults);
                
                const constraints = { video: { width: 320, height: 240, facingMode: "user" } };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = stream;
                await new Promise(r => videoElement.onloadedmetadata = () => { videoElement.play(); r(); });
                
                document.getElementById('progress-fill').style.width = "100%";
                aiReady = true;
                forceHideLoader();
                detectLoop();
            } catch (err) {
                console.log(err);
                setTimeout(() => { 
                    forceHideLoader(); 
                    document.getElementById('cam-wrapper').style.display = 'none'; // éšè—æ‘„åƒå¤´æ¡†
                    updateUI(isMobile ? "è§¦æ‘¸/æ‘„åƒå¤´ä¸å¯ç”¨" : "é¼ æ ‡è°ƒè¯•æ¨¡å¼", isMobile ? "ğŸ‘†" : "ğŸ–±ï¸", "#aaa"); 
                }, 1500);
            }
        }

        async function detectLoop() {
            if (aiReady && videoElement.readyState >= 2) await hands.send({image: videoElement});
            requestAnimationFrame(detectLoop);
        }

        function triggerFireworkBlast() {
            const oldBloom = bloomPass.strength;
            bloomPass.strength = oldBloom * 3.0; 
            setTimeout(() => bloomPass.strength = oldBloom, 300);

            for(let i=0; i<CONFIG.particleCount; i++) {
                const idx = i*3;
                const u = Math.random(); const v = Math.random();
                const theta = 2 * Math.PI * u; const phi = Math.acos(2 * v - 1);
                const sinPhi = Math.sin(phi);
                const dx = sinPhi * Math.cos(theta); const dy = sinPhi * Math.sin(theta); const dz = Math.cos(phi);
                const speedVar = CONFIG.explosionForce * (0.2 + Math.random() * 0.8);
                velocities[idx] = dx * speedVar; velocities[idx+1] = dy * speedVar * 1.2; velocities[idx+2] = dz * speedVar;
            }
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                state.handCenter.x = (lm[9].x - 0.5) * 2; state.handCenter.y = (lm[9].y - 0.5) * 2;
                
                const index=lm[8], middle=lm[12], ring=lm[16], pinky=lm[20];
                state.isFist = (index.y > lm[6].y && middle.y > lm[10].y && ring.y > lm[14].y && pinky.y > lm[18].y);

                const isFireworkMode = (CONFIG.model === "ğŸ† çƒŸèŠ±æ¨¡å¼");
                
                if (isFireworkMode) {
                    if (state.isFist) updateUI("å¼•åŠ›å……èƒ½ (HOLD)", "âœŠ", "#ff0055");
                    else {
                        if (state.wasFist) triggerFireworkBlast();
                        updateUI("è‡ªç”±ç»½æ”¾ (OPEN)", "ğŸ–ï¸", "#00f3ff");
                    }
                } else {
                    if (state.isFist) updateUI("è§†å›¾æ”¾å¤§ (ZOOM)", "âœŠ", "#ff0055");
                    else updateUI("å¸¸æ€è§‚æµ‹ (SCAN)", "ğŸ–ï¸", "#00f3ff");
                }
                state.wasFist = state.isFist;
            } else {
                state.isFist = false;
                updateUI("å¯»æ‰¾ä¿¡å·...", "âš ï¸", "#555");
            }
        }

        // --- Loop ---
        const clock = new THREE.Clock();
        let smoothExpansion = 1.0; 

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            const positionsAttr = geometry.attributes.position;
            const isFireworkMode = (CONFIG.model === "ğŸ† çƒŸèŠ±æ¨¡å¼");

            // Rotation
            if (CONFIG.autoRotate && !state.isFist) scene.rotation.y += 0.002;
            
            // View Control
            const cx = aiReady ? state.handCenter.x : mouse.x;
            const cy = aiReady ? state.handCenter.y : mouse.y;
            if (!state.isFist) {
                const sensitivity = isMobile ? 0.03 : 0.05;
                scene.rotation.x += (cy * 0.2 - scene.rotation.x) * sensitivity;
                scene.rotation.y += (cx * 0.2 - scene.rotation.y) * sensitivity;
            }

            // Breathing / Zoom Logic
            if (!isFireworkMode) {
                const targetScale = state.isFist ? 2.5 : 1.0;
                smoothExpansion += (targetScale - smoothExpansion) * 0.08;
            }

            for(let i=0; i<CONFIG.particleCount; i++) {
                const idx = i*3;
                
                if (isFireworkMode) {
                    if (state.isFist) {
                        const pullSpeed = 0.2; 
                        velocities[idx]   += (0 - currentPositions[idx]) * pullSpeed;
                        velocities[idx+1] += (0 - currentPositions[idx+1]) * pullSpeed;
                        velocities[idx+2] += (0 - currentPositions[idx+2]) * pullSpeed;
                        velocities[idx] *= 0.7; velocities[idx+1] *= 0.7; velocities[idx+2] *= 0.7;
                        
                        const distSq = currentPositions[idx]**2 + currentPositions[idx+1]**2 + currentPositions[idx+2]**2;
                        if(distSq < 20) {
                            currentPositions[idx] += (Math.random()-0.5)*0.2;
                            currentPositions[idx+1] += (Math.random()-0.5)*0.2;
                            currentPositions[idx+2] += (Math.random()-0.5)*0.2;
                        }
                    } else {
                        velocities[idx+1] -= CONFIG.gravity; 
                        velocities[idx] *= CONFIG.friction; velocities[idx+1] *= CONFIG.friction; velocities[idx+2] *= CONFIG.friction;
                    }
                } else {
                    let tx = targetPositions[idx] * smoothExpansion;
                    let ty = targetPositions[idx+1] * smoothExpansion;
                    let tz = targetPositions[idx+2] * smoothExpansion;

                    tx += Math.cos(time*0.5 + i*0.1)*CONFIG.jitter;
                    ty += Math.sin(time*0.5 + i*0.1)*CONFIG.jitter;

                    velocities[idx]   += (tx - currentPositions[idx]) * CONFIG.returnSpeed;
                    velocities[idx+1] += (ty - currentPositions[idx+1]) * CONFIG.returnSpeed;
                    velocities[idx+2] += (tz - currentPositions[idx+2]) * CONFIG.returnSpeed;
                    
                    velocities[idx] *= CONFIG.friction; velocities[idx+1] *= CONFIG.friction; velocities[idx+2] *= CONFIG.friction;
                }

                currentPositions[idx]   += velocities[idx];
                currentPositions[idx+1] += velocities[idx+1];
                currentPositions[idx+2] += velocities[idx+2];
                positionsAttr.array[idx]   = currentPositions[idx];
                positionsAttr.array[idx+1] = currentPositions[idx+1];
                positionsAttr.array[idx+2] = currentPositions[idx+2];
            }
            positionsAttr.needsUpdate = true;
            composer.render();
        }

        // å¯åŠ¨
        switchMode("ğŸ§  ç¥ç»ç½‘ç»œ");
        adjustCamera(); // åˆå§‹è°ƒç”¨é€‚åº”å±å¹•
        
        window.addEventListener('load', initAI);
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth,window.innerHeight); 
            composer.setSize(window.innerWidth,window.innerHeight);
            adjustCamera(); // çª—å£å˜åŒ–æ—¶é‡æ–°é€‚åº”
        });

        animate();
    </script>
</body>
</html>
