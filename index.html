<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CYBERPUNK NEURAL LINK v4.5 // SPARK TRAIL</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root { --neon-blue: #00f3ff; --neon-pink: #ff0055; --neon-yellow: #fcee0a; --bg-dark: #050505; --glass: rgba(0, 20, 30, 0.75); }
        body { margin: 0; overflow: hidden; background-color: var(--bg-dark); font-family: 'Share Tech Mono', monospace; color: var(--neon-blue); user-select: none; }
        
        /* è§†è§‰ç‰¹æ•ˆå±‚ */
        #crt-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06)); background-size: 100% 2px, 3px 100%; pointer-events: none; z-index: 999; }
        #vignette { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.8) 100%); pointer-events: none; z-index: 998; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }

        /* HUD - é¡¶éƒ¨çŠ¶æ€ */
        #hud-top { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); z-index: 10; text-align: center; pointer-events: none; }
        #status-box { 
            border: 1px solid var(--neon-blue); background: var(--glass); padding: 10px 40px; 
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%); 
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.15); backdrop-filter: blur(4px); transition: all 0.3s; 
        }
        #gesture-icon { font-size: 32px; display: block; margin-bottom: 5px; text-shadow: 0 0 10px currentColor; }
        #gesture-text { font-size: 14px; letter-spacing: 3px; font-weight: bold; }

        /* HUD - åº•éƒ¨é¢æ¿ */
        #bottom-panel { position: absolute; bottom: 30px; left: 30px; display: flex; gap: 15px; align-items: flex-end; z-index: 10; }
        #cam-container { position: relative; width: 200px; height: 150px; border: 1px solid var(--neon-pink); background: #000; box-shadow: 0 0 20px rgba(255, 0, 85, 0.1); }
        #cam-container::before { content: ''; position: absolute; top:-2px; left:-2px; width: 10px; height: 10px; border-top: 2px solid var(--neon-pink); border-left: 2px solid var(--neon-pink); }
        #cam-container::after { content: ''; position: absolute; bottom:-2px; right:-2px; width: 10px; height: 10px; border-bottom: 2px solid var(--neon-pink); border-right: 2px solid var(--neon-pink); }
        #video-input { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.6; filter: grayscale(100%) contrast(1.2); }
        
        /* HUD - æ—¥å¿— */
        #debug-log { 
            width: 240px; height: 150px; 
            border-left: 2px solid var(--neon-blue); 
            background: linear-gradient(90deg, rgba(0, 20, 30, 0.8), transparent);
            padding: 10px; box-sizing: border-box;
            font-size: 11px; color: rgba(255,255,255,0.7); 
            display: flex; flex-direction: column; justify-content: flex-end;
            overflow: hidden; 
        }
        .log-line { margin-bottom: 4px; border-bottom: 1px solid rgba(0, 243, 255, 0.1); padding-bottom: 2px; animation: fadeIn 0.3s ease-out; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-family: 'Share Tech Mono'; }

        /* ==================== èµ›åšæ§åˆ¶é¢æ¿ (å³ä¾§) ==================== */
        #cyber-panel {
            position: absolute; top: 50%; right: 20px; transform: translateY(-50%);
            width: 280px;
            background: rgba(5, 10, 15, 0.85);
            border: 1px solid rgba(0, 243, 255, 0.3);
            backdrop-filter: blur(8px);
            z-index: 20;
            padding: 20px;
            clip-path: polygon(
                0 0, 100% 0, 
                100% calc(100% - 20px), calc(100% - 20px) 100%, 
                0 100%
            );
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            font-family: 'Share Tech Mono';
        }
        #cyber-panel::before {
            content: "SYS_CONFIG_V4.5";
            position: absolute; top: -10px; right: 10px;
            background: var(--bg-dark); border: 1px solid var(--neon-blue);
            color: var(--neon-blue); font-size: 10px; padding: 2px 5px;
            letter-spacing: 1px;
        }

        .panel-section { margin-bottom: 20px; border-left: 2px solid rgba(255,255,255,0.1); padding-left: 10px; transition: border-color 0.3s; }
        .panel-section:hover { border-left-color: var(--neon-blue); }
        
        .section-title { 
            color: var(--neon-pink); font-size: 12px; font-weight: bold; margin-bottom: 10px; 
            text-transform: uppercase; letter-spacing: 2px; display: flex; align-items: center;
        }
        .section-title::after { content:''; flex:1; height:1px; background: rgba(255,0,85,0.3); margin-left: 10px; }

        /* è‡ªå®šä¹‰æ§ä»¶æ ·å¼ */
        .control-row { margin-bottom: 12px; }
        .control-label { display: flex; justify-content: space-between; font-size: 11px; color: #aaa; margin-bottom: 4px; }
        .control-val { color: var(--neon-yellow); font-family: 'Orbitron'; }

        /* ä¸‹æ‹‰èœå• */
        select.cyber-select {
            width: 100%; background: #000; border: 1px solid var(--neon-blue); color: var(--neon-blue);
            padding: 5px; font-family: 'Share Tech Mono'; outline: none; cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 243, 255, 0.2);
        }
        select.cyber-select:hover { background: #001a20; }

        /* æ»‘å— (Input Range) */
        input[type=range] {
            -webkit-appearance: none; width: 100%; background: transparent; margin: 5px 0;
        }
        input[type=range]:focus { outline: none; }
        /* è½¨é“ */
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer;
            background: rgba(0, 243, 255, 0.2); border-radius: 0;
            border: 1px solid rgba(0, 243, 255, 0.3);
        }
        /* æ»‘å—å¤´ */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 12px; width: 8px; margin-top: -5px;
            background: var(--neon-blue);
            border: 1px solid #fff;
            box-shadow: 0 0 10px var(--neon-blue);
            cursor: pointer;
        }
        input[type=range]:hover::-webkit-slider-thumb { background: #fff; }

        /* Checkbox */
        .checkbox-row { display: flex; align-items: center; cursor: pointer; font-size: 11px; color: #ccc; }
        .checkbox-row input { margin-right: 10px; accent-color: var(--neon-blue); }

        /* Loading */
        #loader { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 2000; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 0.8s; pointer-events: none; }
        .loader-bar { width: 200px; height: 4px; background: #333; margin-top: 20px; position: relative; overflow: hidden; }
        .loader-progress { position: absolute; top: 0; left: 0; height: 100%; width: 0%; background: var(--neon-blue); box-shadow: 0 0 10px var(--neon-blue); transition: width 0.3s; }
    </style>
    
    <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>

    <div id="crt-overlay"></div>
    <div id="vignette"></div>

    <div id="loader">
        <h1 style="font-family: 'Orbitron'; letter-spacing: 5px; color: var(--neon-blue);">NEURAL LINK v4.5</h1>
        <div class="loader-bar"><div class="loader-progress" id="progress-fill"></div></div>
        <div id="loader-text" style="margin-top: 10px; color: #666; font-size: 12px;">åŠ è½½å…¨æ¯ç•Œé¢...</div>
    </div>

    <div id="hud-top">
        <div id="status-box">
            <span id="gesture-icon">âš ï¸</span>
            <div id="gesture-text">ç­‰å¾…ä¿¡å·</div>
        </div>
    </div>

    <div id="bottom-panel">
        <div id="cam-container">
            <video id="video-input" playsinline muted autoplay></video>
            <div style="position: absolute; top: 2px; left: 2px; font-size: 9px; color: var(--neon-pink); background: black; padding: 1px 4px;">LIVE_FEED</div>
        </div>
        <div id="debug-log"></div>
    </div>

    <div id="cyber-panel">
        <div class="panel-section">
            <div class="section-title">æ ¸å¿ƒæ¨¡å¼ (CORE)</div>
            <div class="control-row">
                <select id="inp-model" class="cyber-select"></select>
            </div>
            <div class="control-row">
                <div class="control-label">å…¨å±€ç¼©æ”¾ <span id="val-scale" class="control-val">1.0</span></div>
                <input type="range" id="inp-scale" min="0.1" max="3.0" step="0.01">
            </div>
            <div class="checkbox-row">
                <input type="checkbox" id="inp-rotate" checked> <label for="inp-rotate">è‡ªåŠ¨æ—‹è½¬ (AUTO-ROT)</label>
            </div>
        </div>

        <div class="panel-section">
            <div class="section-title">è§†è§‰ç³»ç»Ÿ (VISUAL)</div>
            <div class="control-row">
                <div class="control-label">è¾‰å…‰å¼ºåº¦ <span id="val-bloom" class="control-val">1.5</span></div>
                <input type="range" id="inp-bloom" min="0" max="5" step="0.1">
            </div>
            <div class="control-row">
                <div class="control-label">ç²’å­å¤§å° <span id="val-size" class="control-val">0.15</span></div>
                <input type="range" id="inp-size" min="0.01" max="0.5" step="0.01">
            </div>
        </div>

        <div class="panel-section">
            <div class="section-title">ç‰©ç†å¼•æ“ (PHYSICS)</div>
            <div class="control-row">
                <div class="control-label">å°¾è¿¹é•¿åº¦/é˜»åŠ› <span id="val-speed" class="control-val">0.08</span></div>
                <input type="range" id="inp-speed" min="0.01" max="0.3" step="0.001">
            </div>
            <div class="control-row">
                <div class="control-label">çˆ†ç‚¸åŠ›åº¦ <span id="val-force" class="control-val">15.0</span></div>
                <input type="range" id="inp-force" min="1.0" max="30.0" step="0.1">
            </div>
             <div class="control-row">
                <div class="control-label">é‡åŠ›åœº <span id="val-gravity" class="control-val">0.05</span></div>
                <input type="range" id="inp-gravity" min="0.0" max="0.2" step="0.01">
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- DOM ç¼“å­˜ ---
        const logEl = document.getElementById('debug-log');
        const gestureText = document.getElementById('gesture-text');
        const gestureIcon = document.getElementById('gesture-icon');
        const videoElement = document.getElementById('video-input');
        
        // UI Inputs
        const ui = {
            model: document.getElementById('inp-model'),
            scale: document.getElementById('inp-scale'),
            rotate: document.getElementById('inp-rotate'),
            bloom: document.getElementById('inp-bloom'),
            size: document.getElementById('inp-size'),
            speed: document.getElementById('inp-speed'),
            force: document.getElementById('inp-force'),
            gravity: document.getElementById('inp-gravity'),
            // Value labels
            v_scale: document.getElementById('val-scale'),
            v_bloom: document.getElementById('val-bloom'),
            v_size: document.getElementById('val-size'),
            v_speed: document.getElementById('val-speed'),
            v_force: document.getElementById('val-force'),
            v_gravity: document.getElementById('val-gravity'),
        };

        const log = (msg) => {
            if(!logEl) return;
            const line = document.createElement('div');
            line.className = 'log-line';
            line.innerText = `> ${msg}`;
            logEl.appendChild(line);
            while (logEl.childElementCount > 8) logEl.removeChild(logEl.firstChild);
        };

        // --- Config ---
        const CONFIG = {
            model: "ğŸ§  ç¥ç»ç½‘ç»œ",
            particleCount: 40000,
            
            // å€¼ä¼šç”± UI é©±åŠ¨
            globalScale: 2.0,  
            bloomStrength: 1.5,
            particleSize: 0.15,
            colorBase: '#00f3ff', 
            colorAlt: '#ff0055',
            autoRotate: true,
            
            returnSpeed: 0.08,    
            friction: 0.94,      
            jitter: 0.5,       
            gravity: 0.05,        
            explosionForce: 15.0, 
        };

        // --- Three.js ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 35;
        
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        composer.addPass(bloomPass);

        // --- Particles ---
        const tex = (() => {
            const c = document.createElement('canvas'); c.width=16; c.height=16;
            const ctx = c.getContext('2d');
            ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(8,8,6,0,Math.PI*2); ctx.fill(); 
            return new THREE.Texture(c);
        })();
        tex.needsUpdate = true;

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const colors = new Float32Array(CONFIG.particleCount * 3);
        const currentPositions = new Float32Array(CONFIG.particleCount * 3);
        const targetPositions = new Float32Array(CONFIG.particleCount * 3); 
        const velocities = new Float32Array(CONFIG.particleCount * 3);
        
        // æ–°å¢ï¼šç²’å­çš„ç”Ÿå‘½å‘¨æœŸ (0.0 = æ­», 1.0 = æ–°ç”Ÿ)
        const life = new Float32Array(CONFIG.particleCount);
        // æ–°å¢ï¼šéšæœºç§å­
        const randoms = new Float32Array(CONFIG.particleCount);

        for(let i=0; i<CONFIG.particleCount; i++) {
            positions[i*3] = (Math.random()-0.5)*50; positions[i*3+1] = (Math.random()-0.5)*50; positions[i*3+2] = (Math.random()-0.5)*50;
            currentPositions[i*3] = positions[i*3]; currentPositions[i*3+1] = positions[i*3+1]; currentPositions[i*3+2] = positions[i*3+2];
            randoms[i] = Math.random();
            life[i] = 0; // åˆå§‹å…¨æ­»
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: CONFIG.particleSize, map: tex, vertexColors: true,
            blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 1.0
        });
        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        const updateColors = (mode = "default") => {
            const c1 = new THREE.Color(CONFIG.colorBase);
            const c2 = new THREE.Color(CONFIG.colorAlt);
            
            const attr = geometry.attributes.color;
            for(let i=0; i<CONFIG.particleCount; i++) {
                if (mode === "firework") {
                    const r = Math.random();
                    let color = new THREE.Color();
                    if (r > 0.8) color.setHex(0xffffff); 
                    else if (r > 0.6) color.setHex(0xffaa00);
                    else if (r > 0.4) color.setHex(0xff0055);
                    else color.setHSL(Math.random(), 1.0, 0.6);
                    attr.setXYZ(i, color.r, color.g, color.b);
                } else if (mode === "spark") {
                    // åˆå§‹åŒ–ä¸ºæš—è‰²ï¼Œé¢œè‰²å°†åœ¨ animate ä¸­åŸºäº life åŠ¨æ€æ›´æ–°
                    attr.setXYZ(i, 0, 0, 0); 
                } else {
                    const isBlue = Math.random() > 0.5;
                    attr.setXYZ(i, isBlue?c1.r:c2.r, isBlue?c1.g:c2.g, isBlue?c1.b:c2.b);
                }
            }
            attr.needsUpdate = true;
        };
        updateColors();

        // --- Shapes ---
        const shapes = {
            "âœ¨ æŒ‡å°–ç«èŠ± (Finger Spark)": (i) => null, // åŠ¨æ€å‘å°„å™¨
            "ğŸ§  ç¥ç»ç½‘ç»œ": (i) => {
                 const theta = Math.random() * Math.PI * 2, phi = Math.acos(2 * Math.random() - 1);
                 const r = 10 * Math.cbrt(Math.random()); 
                 let x = r * Math.sin(phi) * Math.cos(theta);
                 let y = r * Math.sin(phi) * Math.sin(theta) * 0.8;
                 let z = r * Math.cos(phi);
                 if(x > 0) x += 1; else x -= 1; 
                 return {x,y,z};
            },
            "ğŸª åœŸæ˜Ÿ (Saturn)": (i) => {
                if (i % 3 === 0) {
                    const theta = Math.random() * Math.PI * 2, phi = Math.acos(2 * Math.random() - 1);
                    const r = 4.5;
                    return {x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.sin(phi) * Math.sin(theta), z: r * Math.cos(phi)};
                } else {
                    const theta = Math.random() * Math.PI * 2;
                    const r = 7 + Math.random() * 5; 
                    return {x: r * Math.cos(theta), y: (Math.random()-0.5)*0.2, z: r * Math.sin(theta)};
                }
            },
            "ğŸŒŒ é“¶æ²³ (Galaxy)": (i) => {
                 const arms = 3; const armIndex = i % arms;
                 const r = Math.random() * 12; const spin = r * 0.5; 
                 const theta = (armIndex / arms) * Math.PI * 2 + spin;
                 const randomOffset = (Math.random()-0.5);
                 return { x: r * Math.cos(theta) + randomOffset, y: (Math.random()-0.5) * (2 - r/8), z: r * Math.sin(theta) + randomOffset };
            },
            "ğŸ† çƒŸèŠ±æ¨¡å¼": (i) => null
        };

        // --- UI Logic Binding ---
        Object.keys(shapes).forEach(key => {
            const opt = document.createElement('option');
            opt.value = key; opt.innerText = key;
            ui.model.appendChild(opt);
        });

        function syncUI() {
            ui.scale.value = CONFIG.globalScale; ui.v_scale.innerText = CONFIG.globalScale.toFixed(2);
            ui.rotate.checked = CONFIG.autoRotate;
            ui.bloom.value = CONFIG.bloomStrength; ui.v_bloom.innerText = CONFIG.bloomStrength.toFixed(1);
            ui.size.value = CONFIG.particleSize; ui.v_size.innerText = CONFIG.particleSize.toFixed(2);
            ui.speed.value = CONFIG.returnSpeed; ui.v_speed.innerText = CONFIG.returnSpeed.toFixed(3);
            ui.force.value = CONFIG.explosionForce; ui.v_force.innerText = CONFIG.explosionForce.toFixed(1);
            ui.gravity.value = CONFIG.gravity; ui.v_gravity.innerText = CONFIG.gravity.toFixed(2);
            ui.model.value = CONFIG.model;
        }

        ui.model.addEventListener('change', (e) => switchMode(e.target.value));
        ui.scale.addEventListener('input', (e) => { CONFIG.globalScale = parseFloat(e.target.value); particleSystem.scale.set(CONFIG.globalScale, CONFIG.globalScale, CONFIG.globalScale); ui.v_scale.innerText = CONFIG.globalScale.toFixed(2);});
        ui.rotate.addEventListener('change', (e) => CONFIG.autoRotate = e.target.checked);
        ui.bloom.addEventListener('input', (e) => { CONFIG.bloomStrength = parseFloat(e.target.value); bloomPass.strength = CONFIG.bloomStrength; ui.v_bloom.innerText = CONFIG.bloomStrength.toFixed(1); });
        ui.size.addEventListener('input', (e) => { CONFIG.particleSize = parseFloat(e.target.value); material.size = CONFIG.particleSize; ui.v_size.innerText = CONFIG.particleSize.toFixed(2); });
        ui.speed.addEventListener('input', (e) => { CONFIG.returnSpeed = parseFloat(e.target.value); ui.v_speed.innerText = CONFIG.returnSpeed.toFixed(3); });
        ui.force.addEventListener('input', (e) => { CONFIG.explosionForce = parseFloat(e.target.value); ui.v_force.innerText = CONFIG.explosionForce.toFixed(1); });
        ui.gravity.addEventListener('input', (e) => { CONFIG.gravity = parseFloat(e.target.value); ui.v_gravity.innerText = CONFIG.gravity.toFixed(2); });


        // --- Mode Switching ---
        function switchMode(name) {
            CONFIG.model = name;
            log(`SYSTEM_MODE >> [${name}]`);
            
            const isFirework = (name === "ğŸ† çƒŸèŠ±æ¨¡å¼");
            const isSpark = (name.includes("ç«èŠ±"));

            if (isFirework) {
                updateColors("firework");
                CONFIG.globalScale = 0.1;
                CONFIG.bloomStrength = 2.8;
                CONFIG.particleSize = 0.25;
                CONFIG.returnSpeed = 0.05;
                CONFIG.friction = 0.96;
                CONFIG.gravity = 0.06;
                CONFIG.explosionForce = 15.0;
                updateUI("å‘å°„ç³»ç»Ÿå°±ç»ª", "ğŸš€", "#fcee0a");
            } else if (isSpark) {
                updateColors("spark");
                CONFIG.globalScale = 1.0; 
                CONFIG.bloomStrength = 2.5; // è¶…äº®
                CONFIG.particleSize = 0.3; 
                CONFIG.returnSpeed = 0.05; // è¿™é‡Œç”¨ä½œâ€œé˜»åŠ›â€ç³»æ•°ï¼Œè¶Šå°é˜»åŠ›è¶Šå°
                CONFIG.friction = 0.92; 
                CONFIG.gravity = 0.03;
                CONFIG.autoRotate = false; 
                scene.rotation.set(0,0,0); 
                updateUI("å¾…æœºæ¨¡å¼ (IDLE)", "ğŸ’¤", "#555");
                
                // åˆå§‹å°†æ‰€æœ‰ç²’å­é‡ç½®åˆ°å±å¹•å¤–æˆ–ä¸­å¿ƒ
                for(let i=0; i<CONFIG.particleCount; i++) {
                    life[i] = 0; // å…¨éƒ¨æ€æ­»ï¼Œç­‰å¾…å‘å°„
                    const idx = i*3;
                    // æ”¾åœ¨ä¸­é—´å½¢æˆä¸€ä¸ªå¾…æœºç¯
                    const theta = Math.random() * Math.PI * 2;
                    const r = 5 + Math.random() * 2;
                    currentPositions[idx] = r * Math.cos(theta);
                    currentPositions[idx+1] = r * Math.sin(theta);
                    currentPositions[idx+2] = (Math.random()-0.5) * 2;
                    velocities[idx] = 0; velocities[idx+1] = 0; velocities[idx+2] = 0;
                }

            } else {
                updateColors("default");
                CONFIG.globalScale = 2.0;
                CONFIG.bloomStrength = 0.93;
                CONFIG.particleSize = 0.15;
                CONFIG.returnSpeed = 0.08;
                CONFIG.friction = 0.84;
                CONFIG.gravity = 0.05;
                CONFIG.autoRotate = true;
                
                const gen = shapes[name];
                for(let i=0; i<CONFIG.particleCount; i++) {
                    const p = gen(i);
                    targetPositions[i*3] = p.x; targetPositions[i*3+1] = p.y; targetPositions[i*3+2] = p.z;
                }
                updateUI("æ¨¡å‹åŠ è½½å®Œæˆ", "ğŸ’ ", "#00f3ff");
            }
            
            particleSystem.scale.set(CONFIG.globalScale, CONFIG.globalScale, CONFIG.globalScale);
            bloomPass.strength = CONFIG.bloomStrength;
            material.size = CONFIG.particleSize;
            syncUI();
        }

        function updateUI(text, icon, color) {
            if (!gestureText || !gestureIcon) return;
            if (gestureText.innerText === text) return;
            gestureText.innerText = text;
            gestureText.style.color = color;
            gestureText.parentElement.style.borderColor = color;
            gestureText.parentElement.style.boxShadow = `0 0 15px ${color}40`;
            gestureIcon.innerText = icon;
        }

        // --- Logic ---
        let hands;
        let aiReady = false;
        const mouse = { x: 0, y: 0 };
        const state = { 
            isFist: false, 
            wasFist: false, 
            handCenter: {x:0, y:0},
            indexTip: {x:0, y:0, z:0},
            prevIndexTip: {x:0, y:0, z:0}, // è®°å½•ä¸Šä¸€å¸§ä½ç½®è®¡ç®—é€Ÿåº¦
            isFingerUp: false 
        };

        window.addEventListener('mousemove', (e) => {
            if(!aiReady || CONFIG.model.includes("ç«èŠ±")) {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            }
        });

        function forceHideLoader() {
            const l = document.getElementById('loader');
            if(l) { l.style.opacity = 0; setTimeout(() => l.style.display='none', 800); }
        }

        async function initAI() {
            log("INIT_NEURAL_ENGINE...");
            document.getElementById('progress-fill').style.width = "50%";
            try {
                hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6});
                hands.onResults(onResults);
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240, facingMode: "user" } });
                videoElement.srcObject = stream;
                await new Promise(r => videoElement.onloadedmetadata = () => { videoElement.play(); r(); });
                log("è§†è§‰é“¾è·¯ [CONNECTED]");
                document.getElementById('progress-fill').style.width = "100%";
                aiReady = true;
                forceHideLoader();
                detectLoop();
            } catch (err) {
                log("è§†è§‰é“¾è·¯ä¸­æ–­: " + err.message);
                setTimeout(() => { forceHideLoader(); updateUI("é¼ æ ‡è°ƒè¯•æ¨¡å¼", "ğŸ–±ï¸", "#aaa"); }, 1500);
            }
        }

        async function detectLoop() {
            if (aiReady && videoElement.readyState >= 2) await hands.send({image: videoElement});
            requestAnimationFrame(detectLoop);
        }

        // çƒŸèŠ±é€»è¾‘
        function triggerFireworkBlast() {
            log("DETONATION_SEQUENCE_INIT");
            const oldBloom = bloomPass.strength;
            bloomPass.strength = oldBloom * 3.0; 
            setTimeout(() => bloomPass.strength = oldBloom, 300);

            for(let i=0; i<CONFIG.particleCount; i++) {
                const idx = i*3;
                const u = Math.random(); const v = Math.random();
                const theta = 2 * Math.PI * u; const phi = Math.acos(2 * v - 1);
                const sinPhi = Math.sin(phi);
                const dx = sinPhi * Math.cos(theta); const dy = sinPhi * Math.sin(theta); const dz = Math.cos(phi);
                const speedVar = CONFIG.explosionForce * (0.2 + Math.random() * 0.8);
                velocities[idx] = dx * speedVar; velocities[idx+1] = dy * speedVar * 1.2; velocities[idx+2] = dz * speedVar;
            }
        }

        function onResults(results) {
            const isSparkMode = CONFIG.model.includes("ç«èŠ±");

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                state.handCenter.x = (lm[9].x - 0.5) * 2; state.handCenter.y = (lm[9].y - 0.5) * 2;
                
                // è®°å½•ä¸Šä¸€å¸§
                state.prevIndexTip.x = state.indexTip.x;
                state.prevIndexTip.y = state.indexTip.y;
                state.prevIndexTip.z = state.indexTip.z;

                state.indexTip.x = (lm[8].x - 0.5) * 2;
                state.indexTip.y = (lm[8].y - 0.5) * 2;
                state.indexTip.z = lm[8].z; 

                const index=lm[8], middle=lm[12], ring=lm[16], pinky=lm[20];
                state.isFist = (index.y > lm[6].y && middle.y > lm[10].y && ring.y > lm[14].y && pinky.y > lm[18].y);
                state.isFingerUp = (index.y < lm[6].y && middle.y > lm[10].y);

                const isFireworkMode = (CONFIG.model === "ğŸ† çƒŸèŠ±æ¨¡å¼");
                
                if (isSparkMode) {
                     updateUI("ç²’å­å–·å°„ (EMIT)", "âœ¨", "#fcee0a");
                } else if (isFireworkMode) {
                    if (state.isFist) updateUI("å¼•åŠ›å……èƒ½ (HOLD)", "âœŠ", "#ff0055");
                    else {
                        if (state.wasFist) triggerFireworkBlast();
                        updateUI("è‡ªç”±ç»½æ”¾ (OPEN)", "ğŸ–ï¸", "#00f3ff");
                    }
                } else {
                    if (state.isFist) updateUI("è§†å›¾æ”¾å¤§ (ZOOM)", "âœŠ", "#ff0055");
                    else updateUI("å¸¸æ€è§‚æµ‹ (SCAN)", "ğŸ–ï¸", "#00f3ff");
                }
                state.wasFist = state.isFist;
            } else {
                state.isFist = false;
                state.isFingerUp = false;
                if (isSparkMode) updateUI("ç³»ç»Ÿå¾…æœº (IDLE)", "ğŸ’¤", "#555");
                else updateUI("å¯»æ‰¾ä¿¡å·...", "âš ï¸", "#555");
            }
        }

        // --- Loop ---
        const clock = new THREE.Clock();
        let smoothExpansion = 1.0; 
        
        // ä¸“é—¨ç”¨äº Spark æ¨¡å¼çš„å¾ªç¯æŒ‡é’ˆ
        let spawnIndex = 0; 

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            const positionsAttr = geometry.attributes.position;
            const colorsAttr = geometry.attributes.color;
            
            const isFireworkMode = (CONFIG.model === "ğŸ† çƒŸèŠ±æ¨¡å¼");
            const isSparkMode = CONFIG.model.includes("ç«èŠ±");

            // Rotation
            if (CONFIG.autoRotate && !state.isFist && !isSparkMode) scene.rotation.y += 0.002;
            
            // View Control (æ™®é€šæ¨¡å¼ä¸‹)
            if (!isSparkMode) {
                const cx = aiReady ? state.handCenter.x : mouse.x;
                const cy = aiReady ? state.handCenter.y : mouse.y;
                if (!state.isFist) {
                    scene.rotation.x += (cy * 0.2 - scene.rotation.x) * 0.05;
                    scene.rotation.y += (cx * 0.2 - scene.rotation.y) * 0.05;
                }
                 if (!isFireworkMode) {
                    const targetScale = state.isFist ? 2.5 : 1.0; 
                    smoothExpansion += (targetScale - smoothExpansion) * 0.08;
                }
            }

            // --- æ ¸å¿ƒç‰©ç†å¾ªç¯ ---
            
            let fingerX = 0, fingerY = 0, fingerZ = 0;
            let velX = 0, velY = 0; // æ‰‹æŒ‡ç§»åŠ¨é€Ÿåº¦
            let hasActiveInput = false;

            if (isSparkMode) {
                if (aiReady && state.isFingerUp) {
                    fingerX = -state.indexTip.x * 25; 
                    fingerY = -state.indexTip.y * 15;
                    fingerZ = 0;
                    // è®¡ç®—æ‰‹æŒ‡é€Ÿåº¦ï¼Œç”¨äºç»™ç²’å­æƒ¯æ€§
                    velX = (-state.indexTip.x - -state.prevIndexTip.x) * 25;
                    velY = (-state.indexTip.y - -state.prevIndexTip.y) * 15;
                    hasActiveInput = true;
                } else if (!aiReady) {
                    // é¼ æ ‡æ¨¡æ‹Ÿ
                    fingerX = mouse.x * 25;
                    fingerY = mouse.y * 15;
                    // ç®€å•çš„é¼ æ ‡é€Ÿåº¦æ¨¡æ‹Ÿ
                    hasActiveInput = true; 
                }

                // === ç²’å­å‘å°„é€»è¾‘ (æ¯å¸§å‘å°„ä¸€æ‰¹) ===
                // åªæœ‰æ£€æµ‹åˆ°è¾“å…¥ï¼Œæˆ–è€…åœ¨æ¼”ç¤ºæ¨¡å¼ä¸‹æ‰å‘å°„
                if (hasActiveInput) {
                    const spawnCount = 800; // æ¯å¸§å‘å°„æ•°é‡ï¼Œè¶Šå¤§å°¾è¿¹è¶Šæµ“
                    for(let j=0; j<spawnCount; j++) {
                        spawnIndex = (spawnIndex + 1) % CONFIG.particleCount;
                        life[spawnIndex] = 1.0; // å¤æ´»
                        
                        const idx = spawnIndex * 3;
                        // 1. ä½ç½®ï¼šé‡ç½®åˆ°æŒ‡å°–ï¼ŒåŠ ä¸€ç‚¹éšæœºæŠ–åŠ¨
                        currentPositions[idx]   = fingerX + (Math.random()-0.5) * 0.5;
                        currentPositions[idx+1] = fingerY + (Math.random()-0.5) * 0.5;
                        currentPositions[idx+2] = fingerZ + (Math.random()-0.5) * 0.5;

                        // 2. é€Ÿåº¦ï¼šç»§æ‰¿æ‰‹æŒ‡é€Ÿåº¦ + éšæœºçˆ†ç‚¸é€Ÿåº¦
                        // ç¨å¾®åå‘ä¸€ç‚¹ï¼Œåˆ¶é€ æ‹–å°¾
                        const spread = 0.5;
                        velocities[idx]   = velX * 0.5 + (Math.random()-0.5) * spread;
                        velocities[idx+1] = velY * 0.5 + (Math.random()-0.5) * spread;
                        velocities[idx+2] = (Math.random()-0.5) * spread;
                    }
                }
            }

            for(let i=0; i<CONFIG.particleCount; i++) {
                const idx = i*3;
                
                if (isSparkMode) {
                    // === ç«èŠ±ç‰©ç† ===
                    if (life[i] > 0) {
                        // æ´»ç€ï¼šåº”ç”¨ç‰©ç†
                        velocities[idx]   *= CONFIG.friction; // ç©ºæ°”é˜»åŠ›
                        velocities[idx+1] *= CONFIG.friction;
                        velocities[idx+2] *= CONFIG.friction;
                        
                        velocities[idx+1] -= CONFIG.gravity; // é‡åŠ›ä¸‹å 

                        currentPositions[idx]   += velocities[idx];
                        currentPositions[idx+1] += velocities[idx+1];
                        currentPositions[idx+2] += velocities[idx+2];

                        // é¢œè‰²å’Œé€æ˜åº¦éšå¯¿å‘½è¡°å‡
                        life[i] -= 0.02; // è¡°å‡é€Ÿåº¦

                        // é¢œè‰²æ˜ å°„ï¼š
                        // Life 1.0 -> 0.8 : ç™½/é‡‘ (æ ¸å¿ƒ)
                        // Life 0.8 -> 0.4 : éœ“è™¹è“/ç´« (ä¸­æ®µ)
                        // Life 0.4 -> 0.0 : æš—çº¢/é€æ˜ (å°¾éƒ¨)
                        
                        if (life[i] > 0.8) {
                            colorsAttr.setXYZ(i, 1.0, 1.0, 0.8); // äº®ç™½
                        } else if (life[i] > 0.4) {
                            const t = (life[i] - 0.4) / 0.4;
                            colorsAttr.setXYZ(i, 0.0, t * 1.0, 1.0); // è“æ¸å˜
                        } else {
                            const t = life[i] / 0.4;
                            colorsAttr.setXYZ(i, 0.5 * t, 0.0, 0.5 * t); // ç´«æš—
                        }
                    } else {
                        // æ­»äº†/å¾…æœºä¸­
                        // å¦‚æœæ²¡æœ‰è¾“å…¥ï¼Œè®©å®ƒä»¬åœ¨ä¸­å¿ƒå½¢æˆä¸€ä¸ªå¾…æœºåœ†ç¯ï¼Œè€Œä¸æ˜¯æ¶ˆå¤±
                        if (!hasActiveInput) {
                            const theta = time * 0.2 + i * 0.01;
                            const r = 8 + Math.sin(time + i*0.1) * 2;
                            // ç¼“æ…¢æ—‹è½¬
                            currentPositions[idx]   = Math.cos(theta) * r;
                            currentPositions[idx+1] = Math.sin(theta) * r * 0.5; // å‹æ‰ä¸€ç‚¹
                            currentPositions[idx+2] = Math.sin(time*0.5 + i) * 2;
                            
                            // éå¸¸æš—æ·¡çš„é¢œè‰²
                            colorsAttr.setXYZ(i, 0.0, 0.05, 0.1); 
                        } else {
                             // å¦‚æœæœ‰è¾“å…¥ä½†è¿™ä¸ªç²’å­è¿˜æ²¡è½®åˆ°å‘å°„ï¼Œå°±è—èµ·æ¥
                             currentPositions[idx] = 9999; 
                        }
                    }

                } else if (isFireworkMode) {
                    // ... (ä¿æŒä¸å˜)
                    if (state.isFist) {
                        const pullSpeed = 0.2; 
                        velocities[idx]   += (0 - currentPositions[idx]) * pullSpeed;
                        velocities[idx+1] += (0 - currentPositions[idx+1]) * pullSpeed;
                        velocities[idx+2] += (0 - currentPositions[idx+2]) * pullSpeed;
                        velocities[idx] *= 0.7; velocities[idx+1] *= 0.7; velocities[idx+2] *= 0.7;
                        
                        const distSq = currentPositions[idx]**2 + currentPositions[idx+1]**2 + currentPositions[idx+2]**2;
                        if(distSq < 20) {
                            currentPositions[idx] += (Math.random()-0.5)*0.2;
                            currentPositions[idx+1] += (Math.random()-0.5)*0.2;
                            currentPositions[idx+2] += (Math.random()-0.5)*0.2;
                        }
                    } else {
                        velocities[idx+1] -= CONFIG.gravity; 
                        velocities[idx] *= CONFIG.friction; velocities[idx+1] *= CONFIG.friction; velocities[idx+2] *= CONFIG.friction;
                        currentPositions[idx]   += velocities[idx];
                        currentPositions[idx+1] += velocities[idx+1];
                        currentPositions[idx+2] += velocities[idx+2];
                    }
                } else {
                    // ... (ä¿æŒä¸å˜)
                    let tx = targetPositions[idx] * smoothExpansion;
                    let ty = targetPositions[idx+1] * smoothExpansion;
                    let tz = targetPositions[idx+2] * smoothExpansion;

                    tx += Math.cos(time*0.5 + i*0.1)*CONFIG.jitter;
                    ty += Math.sin(time*0.5 + i*0.1)*CONFIG.jitter;

                    velocities[idx]   += (tx - currentPositions[idx]) * CONFIG.returnSpeed;
                    velocities[idx+1] += (ty - currentPositions[idx+1]) * CONFIG.returnSpeed;
                    velocities[idx+2] += (tz - currentPositions[idx+2]) * CONFIG.returnSpeed;
                    
                    velocities[idx] *= CONFIG.friction; velocities[idx+1] *= CONFIG.friction; velocities[idx+2] *= CONFIG.friction;
                    
                    currentPositions[idx]   += velocities[idx];
                    currentPositions[idx+1] += velocities[idx+1];
                    currentPositions[idx+2] += velocities[idx+2];
                }

                if (!isFireworkMode && !isSparkMode) {
                     // æ™®é€šæ¨¡å¼çš„åæ ‡æ›´æ–°ä¹Ÿåœ¨ä¸Šé¢ç»Ÿä¸€äº†ï¼Œè¿™é‡Œç¡®ä¿ä¸€ä¸‹
                }
                
                positionsAttr.array[idx]   = currentPositions[idx];
                positionsAttr.array[idx+1] = currentPositions[idx+1];
                positionsAttr.array[idx+2] = currentPositions[idx+2];
            }
            positionsAttr.needsUpdate = true;
            if(isSparkMode) colorsAttr.needsUpdate = true; 

            composer.render();
        }

        // é»˜è®¤å¯åŠ¨
        switchMode("ğŸ§  ç¥ç»ç½‘ç»œ");
        
        window.addEventListener('load', initAI);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth,window.innerHeight); composer.setSize(window.innerWidth,window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
