<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CYBERPUNK NEURAL LINK v3.7 // HUD INTERFACE</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root { --neon-blue: #00f3ff; --neon-pink: #ff0055; --neon-yellow: #fcee0a; --bg-dark: #050505; --glass: rgba(0, 20, 30, 0.75); }
        body { margin: 0; overflow: hidden; background-color: var(--bg-dark); font-family: 'Share Tech Mono', monospace; color: var(--neon-blue); user-select: none; }
        
        /* è§†è§‰ç‰¹æ•ˆå±‚ */
        #crt-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06)); background-size: 100% 2px, 3px 100%; pointer-events: none; z-index: 999; }
        #vignette { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.8) 100%); pointer-events: none; z-index: 998; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }

        /* HUD - é¡¶éƒ¨çŠ¶æ€ */
        #hud-top { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); z-index: 10; text-align: center; pointer-events: none; }
        #status-box { 
            border: 1px solid var(--neon-blue); background: var(--glass); padding: 10px 40px; 
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%); 
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.15); backdrop-filter: blur(4px); transition: all 0.3s; 
        }
        #gesture-icon { font-size: 32px; display: block; margin-bottom: 5px; text-shadow: 0 0 10px currentColor; }
        #gesture-text { font-size: 14px; letter-spacing: 3px; font-weight: bold; }

        /* HUD - åº•éƒ¨é¢æ¿ */
        #bottom-panel { position: absolute; bottom: 30px; left: 30px; display: flex; gap: 15px; align-items: flex-end; z-index: 10; }
        #cam-container { position: relative; width: 200px; height: 150px; border: 1px solid var(--neon-pink); background: #000; box-shadow: 0 0 20px rgba(255, 0, 85, 0.1); }
        #cam-container::before { content: ''; position: absolute; top:-2px; left:-2px; width: 10px; height: 10px; border-top: 2px solid var(--neon-pink); border-left: 2px solid var(--neon-pink); }
        #cam-container::after { content: ''; position: absolute; bottom:-2px; right:-2px; width: 10px; height: 10px; border-bottom: 2px solid var(--neon-pink); border-right: 2px solid var(--neon-pink); }
        #video-input { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.6; filter: grayscale(100%) contrast(1.2); }
        
        /* HUD - æ—¥å¿— */
        #debug-log { 
            width: 240px; height: 150px; 
            border-left: 2px solid var(--neon-blue); 
            background: linear-gradient(90deg, rgba(0, 20, 30, 0.8), transparent);
            padding: 10px; box-sizing: border-box;
            font-size: 11px; color: rgba(255,255,255,0.7); 
            display: flex; flex-direction: column; justify-content: flex-end;
            overflow: hidden; 
        }
        .log-line { margin-bottom: 4px; border-bottom: 1px solid rgba(0, 243, 255, 0.1); padding-bottom: 2px; animation: fadeIn 0.3s ease-out; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-family: 'Share Tech Mono'; }

        /* ==================== èµ›åšæ§åˆ¶é¢æ¿ (å³ä¾§) ==================== */
        #cyber-panel {
            position: absolute; top: 50%; right: 20px; transform: translateY(-50%);
            width: 280px;
            background: rgba(5, 10, 15, 0.85);
            border: 1px solid rgba(0, 243, 255, 0.3);
            backdrop-filter: blur(8px);
            z-index: 20;
            padding: 20px;
            clip-path: polygon(
                0 0, 100% 0, 
                100% calc(100% - 20px), calc(100% - 20px) 100%, 
                0 100%
            );
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            font-family: 'Share Tech Mono';
        }
        #cyber-panel::before {
            content: "SYS_CONFIG_V3.7";
            position: absolute; top: -10px; right: 10px;
            background: var(--bg-dark); border: 1px solid var(--neon-blue);
            color: var(--neon-blue); font-size: 10px; padding: 2px 5px;
            letter-spacing: 1px;
        }

        .panel-section { margin-bottom: 20px; border-left: 2px solid rgba(255,255,255,0.1); padding-left: 10px; transition: border-color 0.3s; }
        .panel-section:hover { border-left-color: var(--neon-blue); }
        
        .section-title { 
            color: var(--neon-pink); font-size: 12px; font-weight: bold; margin-bottom: 10px; 
            text-transform: uppercase; letter-spacing: 2px; display: flex; align-items: center;
        }
        .section-title::after { content:''; flex:1; height:1px; background: rgba(255,0,85,0.3); margin-left: 10px; }

        /* è‡ªå®šä¹‰æ§ä»¶æ ·å¼ */
        .control-row { margin-bottom: 12px; }
        .control-label { display: flex; justify-content: space-between; font-size: 11px; color: #aaa; margin-bottom: 4px; }
        .control-val { color: var(--neon-yellow); font-family: 'Orbitron'; }

        /* ä¸‹æ‹‰èœå• */
        select.cyber-select {
            width: 100%; background: #000; border: 1px solid var(--neon-blue); color: var(--neon-blue);
            padding: 5px; font-family: 'Share Tech Mono'; outline: none; cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 243, 255, 0.2);
        }
        select.cyber-select:hover { background: #001a20; }

        /* æ»‘å— (Input Range) */
        input[type=range] {
            -webkit-appearance: none; width: 100%; background: transparent; margin: 5px 0;
        }
        input[type=range]:focus { outline: none; }
        /* è½¨é“ */
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer;
            background: rgba(0, 243, 255, 0.2); border-radius: 0;
            border: 1px solid rgba(0, 243, 255, 0.3);
        }
        /* æ»‘å—å¤´ */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 12px; width: 8px; margin-top: -5px;
            background: var(--neon-blue);
            border: 1px solid #fff;
            box-shadow: 0 0 10px var(--neon-blue);
            cursor: pointer;
        }
        input[type=range]:hover::-webkit-slider-thumb { background: #fff; }

        /* Checkbox */
        .checkbox-row { display: flex; align-items: center; cursor: pointer; font-size: 11px; color: #ccc; }
        .checkbox-row input { margin-right: 10px; accent-color: var(--neon-blue); }

        /* Loading */
        #loader { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 2000; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 0.8s; pointer-events: none; }
        .loader-bar { width: 200px; height: 4px; background: #333; margin-top: 20px; position: relative; overflow: hidden; }
        .loader-progress { position: absolute; top: 0; left: 0; height: 100%; width: 0%; background: var(--neon-blue); box-shadow: 0 0 10px var(--neon-blue); transition: width 0.3s; }
    </style>
    
    <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
</head>
<body>

    <div id="crt-overlay"></div>
    <div id="vignette"></div>

    <div id="loader">
        <h1 style="font-family: 'Orbitron'; letter-spacing: 5px; color: var(--neon-blue);">NEURAL LINK v3.7</h1>
        <div class="loader-bar"><div class="loader-progress" id="progress-fill"></div></div>
        <div id="loader-text" style="margin-top: 10px; color: #666; font-size: 12px;">åŠ è½½å…¨æ¯ç•Œé¢...</div>
    </div>

    <div id="hud-top">
        <div id="status-box">
            <span id="gesture-icon">âš ï¸</span>
            <div id="gesture-text">ç­‰å¾…ä¿¡å·</div>
        </div>
    </div>

    <div id="bottom-panel">
        <div id="cam-container">
            <video id="video-input" playsinline muted autoplay></video>
            <div style="position: absolute; top: 2px; left: 2px; font-size: 9px; color: var(--neon-pink); background: black; padding: 1px 4px;">LIVE_FEED</div>
        </div>
        <div id="debug-log"></div>
    </div>

    <div id="cyber-panel">
        <div class="panel-section">
            <div class="section-title">æ ¸å¿ƒæ¨¡å¼ (CORE)</div>
            <div class="control-row">
                <select id="inp-model" class="cyber-select"></select>
            </div>
            <div class="control-row">
                <div class="control-label">å…¨å±€ç¼©æ”¾ <span id="val-scale" class="control-val">1.0</span></div>
                <input type="range" id="inp-scale" min="0.1" max="3.0" step="0.01">
            </div>
            <div class="checkbox-row">
                <input type="checkbox" id="inp-rotate" checked> <label for="inp-rotate">è‡ªåŠ¨æ—‹è½¬ (AUTO-ROT)</label>
            </div>
        </div>

        <div class="panel-section">
            <div class="section-title">è§†è§‰ç³»ç»Ÿ (VISUAL)</div>
            <div class="control-row">
                <div class="control-label">è¾‰å…‰å¼ºåº¦ <span id="val-bloom" class="control-val">1.5</span></div>
                <input type="range" id="inp-bloom" min="0" max="5" step="0.1">
            </div>
            <div class="control-row">
                <div class="control-label">ç²’å­å¤§å° <span id="val-size" class="control-val">0.15</span></div>
                <input type="range" id="inp-size" min="0.01" max="0.5" step="0.01">
            </div>
        </div>

        <div class="panel-section">
            <div class="section-title">ç‰©ç†å¼•æ“ (PHYSICS)</div>
            <div class="control-row">
                <div class="control-label">å¸é™„é€Ÿåº¦ <span id="val-speed" class="control-val">0.08</span></div>
                <input type="range" id="inp-speed" min="0.01" max="0.3" step="0.001">
            </div>
            <div class="control-row">
                <div class="control-label">çˆ†ç‚¸åŠ›åº¦ <span id="val-force" class="control-val">15.0</span></div>
                <input type="range" id="inp-force" min="1.0" max="30.0" step="0.1">
            </div>
             <div class="control-row">
                <div class="control-label">é‡åŠ›åœº <span id="val-gravity" class="control-val">0.05</span></div>
                <input type="range" id="inp-gravity" min="0.0" max="0.2" step="0.01">
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- DOM ç¼“å­˜ ---
        const logEl = document.getElementById('debug-log');
        const gestureText = document.getElementById('gesture-text');
        const gestureIcon = document.getElementById('gesture-icon');
        const videoElement = document.getElementById('video-input');
        
        // UI Inputs
        const ui = {
            model: document.getElementById('inp-model'),
            scale: document.getElementById('inp-scale'),
            rotate: document.getElementById('inp-rotate'),
            bloom: document.getElementById('inp-bloom'),
            size: document.getElementById('inp-size'),
            speed: document.getElementById('inp-speed'),
            force: document.getElementById('inp-force'),
            gravity: document.getElementById('inp-gravity'),
            // Value labels
            v_scale: document.getElementById('val-scale'),
            v_bloom: document.getElementById('val-bloom'),
            v_size: document.getElementById('val-size'),
            v_speed: document.getElementById('val-speed'),
            v_force: document.getElementById('val-force'),
            v_gravity: document.getElementById('val-gravity'),
        };

        const log = (msg) => {
            if(!logEl) return;
            const line = document.createElement('div');
            line.className = 'log-line';
            line.innerText = `> ${msg}`;
            logEl.appendChild(line);
            while (logEl.childElementCount > 8) logEl.removeChild(logEl.firstChild);
        };

        // --- Config ---
        const CONFIG = {
            model: "ğŸ§  ç¥ç»ç½‘ç»œ",
            particleCount: 35000,
            
            // å€¼ä¼šç”± UI é©±åŠ¨
            globalScale: 2.0,  
            bloomStrength: 1.5,
            particleSize: 0.15,
            colorBase: '#00f3ff', 
            colorAlt: '#ff0055',
            autoRotate: true,
            
            returnSpeed: 0.08,    
            friction: 0.94,      
            jitter: 0.5,       
            gravity: 0.05,        
            explosionForce: 15.0, 
        };

        // --- Three.js ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 35;
        
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        composer.addPass(bloomPass);

        // --- Particles ---
        const tex = (() => {
            const c = document.createElement('canvas'); c.width=16; c.height=16;
            const ctx = c.getContext('2d');
            ctx.fillStyle = '#ffffff'; ctx.fillRect(4,4,8,8);
            return new THREE.Texture(c);
        })();
        tex.needsUpdate = true;

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const colors = new Float32Array(CONFIG.particleCount * 3);
        const currentPositions = new Float32Array(CONFIG.particleCount * 3);
        const targetPositions = new Float32Array(CONFIG.particleCount * 3); 
        const velocities = new Float32Array(CONFIG.particleCount * 3);

        for(let i=0; i<CONFIG.particleCount; i++) {
            positions[i*3] = (Math.random()-0.5)*5; positions[i*3+1] = (Math.random()-0.5)*5; positions[i*3+2] = (Math.random()-0.5)*5;
            currentPositions[i*3] = positions[i*3]; currentPositions[i*3+1] = positions[i*3+1]; currentPositions[i*3+2] = positions[i*3+2];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: CONFIG.particleSize, map: tex, vertexColors: true,
            blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.9
        });
        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        const updateColors = (isFirework = false) => {
            const c1 = new THREE.Color(CONFIG.colorBase);
            const c2 = new THREE.Color(CONFIG.colorAlt);
            const attr = geometry.attributes.color;
            for(let i=0; i<CONFIG.particleCount; i++) {
                if (isFirework) {
                    const r = Math.random();
                    let color = new THREE.Color();
                    if (r > 0.8) color.setHex(0xffffff); 
                    else if (r > 0.6) color.setHex(0xffaa00);
                    else if (r > 0.4) color.setHex(0xff0055);
                    else if (r > 0.2) color.setHex(0x00f3ff);
                    else color.setHSL(Math.random(), 1.0, 0.6);
                    attr.setXYZ(i, color.r, color.g, color.b);
                } else {
                    const isBlue = Math.random() > 0.5;
                    attr.setXYZ(i, isBlue?c1.r:c2.r, isBlue?c1.g:c2.g, isBlue?c1.b:c2.b);
                }
            }
            attr.needsUpdate = true;
        };
        updateColors();

        // --- Shapes ---
        const shapes = {
            "ğŸ§  ç¥ç»ç½‘ç»œ": (i) => {
                 const theta = Math.random() * Math.PI * 2, phi = Math.acos(2 * Math.random() - 1);
                 const r = 10 * Math.cbrt(Math.random()); 
                 let x = r * Math.sin(phi) * Math.cos(theta);
                 let y = r * Math.sin(phi) * Math.sin(theta) * 0.8;
                 let z = r * Math.cos(phi);
                 if(x > 0) x += 1; else x -= 1; 
                 return {x,y,z};
            },
            "ğŸª åœŸæ˜Ÿ (Saturn)": (i) => {
                if (i % 3 === 0) {
                    const theta = Math.random() * Math.PI * 2, phi = Math.acos(2 * Math.random() - 1);
                    const r = 4.5;
                    return {x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.sin(phi) * Math.sin(theta), z: r * Math.cos(phi)};
                } else {
                    const theta = Math.random() * Math.PI * 2;
                    const r = 7 + Math.random() * 5; 
                    return {x: r * Math.cos(theta), y: (Math.random()-0.5)*0.2, z: r * Math.sin(theta)};
                }
            },
            "ğŸŒŒ é“¶æ²³ (Galaxy)": (i) => {
                 const arms = 3; const armIndex = i % arms;
                 const r = Math.random() * 12; const spin = r * 0.5; 
                 const theta = (armIndex / arms) * Math.PI * 2 + spin;
                 const randomOffset = (Math.random()-0.5);
                 return { x: r * Math.cos(theta) + randomOffset, y: (Math.random()-0.5) * (2 - r/8), z: r * Math.sin(theta) + randomOffset };
            },
            "ğŸ† çƒŸèŠ±æ¨¡å¼": (i) => null
        };

        // --- UI Logic Binding ---
        // 1. å¡«å……ä¸‹æ‹‰èœå•
        Object.keys(shapes).forEach(key => {
            const opt = document.createElement('option');
            opt.value = key; opt.innerText = key;
            ui.model.appendChild(opt);
        });

        // 2. è¾…åŠ©å‡½æ•°ï¼šæ›´æ–°UIæ•°å€¼æ˜¾ç¤º
        function syncUI() {
            ui.scale.value = CONFIG.globalScale; ui.v_scale.innerText = CONFIG.globalScale.toFixed(2);
            ui.rotate.checked = CONFIG.autoRotate;
            ui.bloom.value = CONFIG.bloomStrength; ui.v_bloom.innerText = CONFIG.bloomStrength.toFixed(1);
            ui.size.value = CONFIG.particleSize; ui.v_size.innerText = CONFIG.particleSize.toFixed(2);
            ui.speed.value = CONFIG.returnSpeed; ui.v_speed.innerText = CONFIG.returnSpeed.toFixed(3);
            ui.force.value = CONFIG.explosionForce; ui.v_force.innerText = CONFIG.explosionForce.toFixed(1);
            ui.gravity.value = CONFIG.gravity; ui.v_gravity.innerText = CONFIG.gravity.toFixed(2);
            ui.model.value = CONFIG.model;
        }

        // 3. äº‹ä»¶ç›‘å¬
        ui.model.addEventListener('change', (e) => switchMode(e.target.value));
        
        ui.scale.addEventListener('input', (e) => { 
            CONFIG.globalScale = parseFloat(e.target.value); 
            particleSystem.scale.set(CONFIG.globalScale, CONFIG.globalScale, CONFIG.globalScale); 
            ui.v_scale.innerText = CONFIG.globalScale.toFixed(2);
        });
        ui.rotate.addEventListener('change', (e) => CONFIG.autoRotate = e.target.checked);
        
        ui.bloom.addEventListener('input', (e) => {
            CONFIG.bloomStrength = parseFloat(e.target.value);
            bloomPass.strength = CONFIG.bloomStrength;
            ui.v_bloom.innerText = CONFIG.bloomStrength.toFixed(1);
        });
        ui.size.addEventListener('input', (e) => {
            CONFIG.particleSize = parseFloat(e.target.value);
            material.size = CONFIG.particleSize;
            ui.v_size.innerText = CONFIG.particleSize.toFixed(2);
        });
        ui.speed.addEventListener('input', (e) => { CONFIG.returnSpeed = parseFloat(e.target.value); ui.v_speed.innerText = CONFIG.returnSpeed.toFixed(3); });
        ui.force.addEventListener('input', (e) => { CONFIG.explosionForce = parseFloat(e.target.value); ui.v_force.innerText = CONFIG.explosionForce.toFixed(1); });
        ui.gravity.addEventListener('input', (e) => { CONFIG.gravity = parseFloat(e.target.value); ui.v_gravity.innerText = CONFIG.gravity.toFixed(2); });


        // --- Mode Switching ---
        function switchMode(name) {
            CONFIG.model = name;
            const isFirework = (name === "ğŸ† çƒŸèŠ±æ¨¡å¼");
            log(`SYSTEM_MODE >> [${name}]`);
            updateColors(isFirework);

            if (isFirework) {
                // çƒŸèŠ±é¢„è®¾
                CONFIG.globalScale = 0.1;
                CONFIG.bloomStrength = 2.8;
                CONFIG.particleSize = 0.25;
                CONFIG.returnSpeed = 0.05;
                CONFIG.friction = 0.96;
                CONFIG.gravity = 0.06;
                CONFIG.explosionForce = 15.0;
                
                updateUI("å‘å°„ç³»ç»Ÿå°±ç»ª", "ğŸš€", "#fcee0a");
            } else {
                // æ™®é€šé¢„è®¾
                CONFIG.globalScale = 2.0;
                CONFIG.bloomStrength = 0.93;
                CONFIG.particleSize = 0.15;
                CONFIG.returnSpeed = 0.08;
                CONFIG.friction = 0.84;
                CONFIG.gravity = 0.05; // è™½ä¸å¸¸ç”¨ï¼Œä½†ä¹Ÿé‡ç½®ä¸€ä¸‹
                
                const gen = shapes[name];
                for(let i=0; i<CONFIG.particleCount; i++) {
                    const p = gen(i);
                    targetPositions[i*3] = p.x; targetPositions[i*3+1] = p.y; targetPositions[i*3+2] = p.z;
                }
                updateUI("æ¨¡å‹åŠ è½½å®Œæˆ", "ğŸ’ ", "#00f3ff");
            }
            
            // åº”ç”¨åˆ°åœºæ™¯å’ŒUI
            particleSystem.scale.set(CONFIG.globalScale, CONFIG.globalScale, CONFIG.globalScale);
            bloomPass.strength = CONFIG.bloomStrength;
            material.size = CONFIG.particleSize;
            syncUI(); // å…³é”®ï¼šæ›´æ–°æ»‘å—ä½ç½®
        }

        function updateUI(text, icon, color) {
            if (!gestureText || !gestureIcon) return;
            if (gestureText.innerText !== text) {
                gestureText.innerText = text;
                gestureText.style.color = color;
                gestureText.parentElement.style.borderColor = color;
                gestureText.parentElement.style.boxShadow = `0 0 15px ${color}40`;
                gestureIcon.innerText = icon;
            }
        }

        // --- Logic ---
        let hands;
        let aiReady = false;
        const mouse = { x: 0, y: 0 };
        const state = { isFist: false, wasFist: false, handCenter: {x:0, y:0} };

        window.addEventListener('mousemove', (e) => {
            if(!aiReady) {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            }
        });

        function forceHideLoader() {
            const l = document.getElementById('loader');
            if(l) { l.style.opacity = 0; setTimeout(() => l.style.display='none', 800); }
        }

        async function initAI() {
            log("INIT_NEURAL_ENGINE...");
            document.getElementById('progress-fill').style.width = "50%";
            try {
                hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6});
                hands.onResults(onResults);
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240, facingMode: "user" } });
                videoElement.srcObject = stream;
                await new Promise(r => videoElement.onloadedmetadata = () => { videoElement.play(); r(); });
                log("è§†è§‰é“¾è·¯ [CONNECTED]");
                document.getElementById('progress-fill').style.width = "100%";
                aiReady = true;
                forceHideLoader();
                detectLoop();
            } catch (err) {
                log("è§†è§‰é“¾è·¯ä¸­æ–­: " + err.message);
                setTimeout(() => { forceHideLoader(); updateUI("é¼ æ ‡è°ƒè¯•æ¨¡å¼", "ğŸ–±ï¸", "#aaa"); }, 1500);
            }
        }

        async function detectLoop() {
            if (aiReady && videoElement.readyState >= 2) await hands.send({image: videoElement});
            requestAnimationFrame(detectLoop);
        }

        function triggerFireworkBlast() {
            log("DETONATION_SEQUENCE_INIT");
            const oldBloom = bloomPass.strength;
            bloomPass.strength = oldBloom * 3.0; 
            setTimeout(() => bloomPass.strength = oldBloom, 300);

            for(let i=0; i<CONFIG.particleCount; i++) {
                const idx = i*3;
                const u = Math.random(); const v = Math.random();
                const theta = 2 * Math.PI * u; const phi = Math.acos(2 * v - 1);
                const sinPhi = Math.sin(phi);
                const dx = sinPhi * Math.cos(theta); const dy = sinPhi * Math.sin(theta); const dz = Math.cos(phi);
                const speedVar = CONFIG.explosionForce * (0.2 + Math.random() * 0.8);
                velocities[idx] = dx * speedVar; velocities[idx+1] = dy * speedVar * 1.2; velocities[idx+2] = dz * speedVar;
            }
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                state.handCenter.x = (lm[9].x - 0.5) * 2; state.handCenter.y = (lm[9].y - 0.5) * 2;
                
                const index=lm[8], middle=lm[12], ring=lm[16], pinky=lm[20];
                state.isFist = (index.y > lm[6].y && middle.y > lm[10].y && ring.y > lm[14].y && pinky.y > lm[18].y);

                const isFireworkMode = (CONFIG.model === "ğŸ† çƒŸèŠ±æ¨¡å¼");
                
                if (isFireworkMode) {
                    if (state.isFist) updateUI("å¼•åŠ›å……èƒ½ (HOLD)", "âœŠ", "#ff0055");
                    else {
                        if (state.wasFist) triggerFireworkBlast();
                        updateUI("è‡ªç”±ç»½æ”¾ (OPEN)", "ğŸ–ï¸", "#00f3ff");
                    }
                } else {
                    if (state.isFist) updateUI("è§†å›¾æ”¾å¤§ (ZOOM)", "âœŠ", "#ff0055");
                    else updateUI("å¸¸æ€è§‚æµ‹ (SCAN)", "ğŸ–ï¸", "#00f3ff");
                }
                state.wasFist = state.isFist;
            } else {
                state.isFist = false;
                updateUI("å¯»æ‰¾ä¿¡å·...", "âš ï¸", "#555");
            }
        }

        // --- Loop ---
        const clock = new THREE.Clock();
        let smoothExpansion = 1.0; 

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            const positionsAttr = geometry.attributes.position;
            const isFireworkMode = (CONFIG.model === "ğŸ† çƒŸèŠ±æ¨¡å¼");

            // Rotation
            if (CONFIG.autoRotate && !state.isFist) scene.rotation.y += 0.002;
            
            // View Control
            const cx = aiReady ? state.handCenter.x : mouse.x;
            const cy = aiReady ? state.handCenter.y : mouse.y;
            if (!state.isFist) {
                scene.rotation.x += (cy * 0.2 - scene.rotation.x) * 0.05;
                scene.rotation.y += (cx * 0.2 - scene.rotation.y) * 0.05;
            }

            // Breathing / Zoom Logic
            if (!isFireworkMode) {
                const targetScale = state.isFist ? 2.5 : 1.0; // æ¡æ‹³æ”¾å¤§åˆ°2.5å€
                smoothExpansion += (targetScale - smoothExpansion) * 0.08;
            }

            for(let i=0; i<CONFIG.particleCount; i++) {
                const idx = i*3;
                
                if (isFireworkMode) {
                    if (state.isFist) {
                        const pullSpeed = 0.2; 
                        velocities[idx]   += (0 - currentPositions[idx]) * pullSpeed;
                        velocities[idx+1] += (0 - currentPositions[idx+1]) * pullSpeed;
                        velocities[idx+2] += (0 - currentPositions[idx+2]) * pullSpeed;
                        velocities[idx] *= 0.7; velocities[idx+1] *= 0.7; velocities[idx+2] *= 0.7;
                        
                        const distSq = currentPositions[idx]**2 + currentPositions[idx+1]**2 + currentPositions[idx+2]**2;
                        if(distSq < 20) {
                            currentPositions[idx] += (Math.random()-0.5)*0.2;
                            currentPositions[idx+1] += (Math.random()-0.5)*0.2;
                            currentPositions[idx+2] += (Math.random()-0.5)*0.2;
                        }
                    } else {
                        velocities[idx+1] -= CONFIG.gravity; 
                        velocities[idx] *= CONFIG.friction; velocities[idx+1] *= CONFIG.friction; velocities[idx+2] *= CONFIG.friction;
                    }
                } else {
                    let tx = targetPositions[idx] * smoothExpansion;
                    let ty = targetPositions[idx+1] * smoothExpansion;
                    let tz = targetPositions[idx+2] * smoothExpansion;

                    tx += Math.cos(time*0.5 + i*0.1)*CONFIG.jitter;
                    ty += Math.sin(time*0.5 + i*0.1)*CONFIG.jitter;

                    velocities[idx]   += (tx - currentPositions[idx]) * CONFIG.returnSpeed;
                    velocities[idx+1] += (ty - currentPositions[idx+1]) * CONFIG.returnSpeed;
                    velocities[idx+2] += (tz - currentPositions[idx+2]) * CONFIG.returnSpeed;
                    
                    velocities[idx] *= CONFIG.friction; velocities[idx+1] *= CONFIG.friction; velocities[idx+2] *= CONFIG.friction;
                }

                currentPositions[idx]   += velocities[idx];
                currentPositions[idx+1] += velocities[idx+1];
                currentPositions[idx+2] += velocities[idx+2];
                positionsAttr.array[idx]   = currentPositions[idx];
                positionsAttr.array[idx+1] = currentPositions[idx+1];
                positionsAttr.array[idx+2] = currentPositions[idx+2];
            }
            positionsAttr.needsUpdate = true;
            composer.render();
        }

        // é»˜è®¤å¯åŠ¨
        switchMode("ğŸ§  ç¥ç»ç½‘ç»œ");
        
        window.addEventListener('load', initAI);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth,window.innerHeight); composer.setSize(window.innerWidth,window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
